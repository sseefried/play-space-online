/* -*-javascript-*- */
var interval = 15; /* milliseconds between frames */
var meshSize = 500; /* Number of squares in the mesh. Number of triangles is twice this */
var slowDownFactor = 1000.0; /* Time since start (in milliseconds) is divided by this value */
var KeyState = { up: 0, down:  1 }; /* enumeration */
var Axis = { x: 0, y: 1, z: 2};     /* enumeration */
var RotationDirection = { positive: 0, negative: 1 };
var Direction = { positive: 0, negative: 1};

var initVelocity = 0.0;    /* Initial rotation velocity. radians per second (1/s) */
var acceleration = 5.0;  /* Acceleration. radians per second per second. (1/s^2) */
var maxVelocity  = 10.0;
var maxZoomVelocity = 4.0;

function initGL(canvas) {
    var gl;
    try {
        gl = canvas.getContext("experimental-webgl", { antialias: true } );
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
        return gl;
    } catch (e) {
        return;
    }
}

function getShader(gl, id) {
    var shaderScript = document.getElementById(id);
    if (!shaderScript) {
        return null;
    }

    var str = "";
    var k = shaderScript.firstChild;
    while (k) {
        if (k.nodeType === 3) {
            str += k.textContent;
        }
        k = k.nextSibling;
    }

    var shader;
    if (shaderScript.type === "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type === "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
        return null;
    }

    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
}

function addShadyUIs(name, gl, shaderProgram) {
  var shady_ui_spec   = $('#' + name + '.shady-ui-spec');
  var shady_ui_widgets = $('#' + name + '.shady-ui-widgets');

  var shady_ui_specs = eval(shady_ui_spec.text());


  var show_ui = (shady_ui_spec.attr('show-ui') || "true") === "true" ? true : false ;

  var i=0;
  for (i=0; i < shady_ui_specs.length; i++) {
    Shady.addUI(shady_ui_widgets, shady_ui_specs[i], show_ui);
  }

  /* Link up uniforms */
  shady_ui_widgets.find('.shady-ui').each(function() {
    var uniform_name; 
    if ( uniform_name = $(this).attr("glsl-name") ) {
      shaderProgram[uniform_name] = gl.getUniformLocation(shaderProgram, uniform_name);
    }
  })

}

function initShaders(gl, name) {
    var fragmentShader = getShader(gl, "shader-fs-" + name);
    var vertexShader   = getShader(gl, "shader-vs-" + name);

    var shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert("Could not initialise shaders");
    }

    gl.useProgram(shaderProgram);

    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "mesh_coords");
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

    /* 
     * We add several properties to the shaderProgram object here. They are all
     * GLSL uniform locations.
     */
    shaderProgram.mvpMatrixUniform = gl.getUniformLocation(shaderProgram,
                                                           "ModelViewProjectionMatrix");

    shaderProgram.normalMatrixUniform = gl.getUniformLocation(shaderProgram, "NormalMatrix");
    shaderProgram.zoomUniform = gl.getUniformLocation(shaderProgram, "zoom");
    shaderProgram.phiUniform = gl.getUniformLocation(shaderProgram, "phi");
    shaderProgram.thetaUniform = gl.getUniformLocation(shaderProgram, "theta");

    addShadyUIs(name, gl, shaderProgram);


    return shaderProgram;
}

function initBuffers(gl) {
    var squareVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
    vertices = mesh(meshSize,2.0);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    squareVertexPositionBuffer.itemSize = 2;
    squareVertexPositionBuffer.numItems = vertices.length / 2 ;
    return squareVertexPositionBuffer;
}

/* For some reason WebGL just hates the (x,y) value (0.0, 0.0). We add a small error value
   to prevent this problem */
function mesh(n,width) {
    var a = new Float32Array(2*(2*(n*(n+1))  + 2*(n-1)   ));
    var i, j, len = 0;
    var delta = width / n + 0.000000000000001;

    var x, y = -(width/2.0);
    for (j = 0; j < n; j++, y+=delta) {
        if (j > 0) {
            /* Degenerate triangles */
            a[len++] = (width/2.0); // x value
            a[len++] = y; // y value
            a[len++] = -(width/2); // x value
            a[len++] = y; // y value
        }

        for (i = 0, x = -(width/2); i <= n; i++, x+=delta) {
            a[len++] = x; // x value
            a[len++] = y; // y value
            a[len++] = x; // x value
            a[len++] = y+delta; // y value
        }
    }
    return a;
}

function rotateView(last, now, key_values, mvpMatrix) {
  rotateAboutAxis(last, now, key_values.up,    RotationDirection.positive, Axis.x, mvpMatrix);
  rotateAboutAxis(last, now, key_values.down,  RotationDirection.negative, Axis.x, mvpMatrix);
  rotateAboutAxis(last, now, key_values.left,  RotationDirection.positive, Axis.y, mvpMatrix);
  rotateAboutAxis(last, now, key_values.right, RotationDirection.negative, Axis.y, mvpMatrix);
}


/* 
 * Returns the duration that the key was depressed during the time interval [last,now].
 *
 * Expects @key_values@ to be an object with downTime and upTime fields 
 */
function getDownDuration(last,now,key_values) {
  var keyDown = key_values.downTime >= last && key_values.downTime < now,
      keyUp   = key_values.upTime   >= last && key_values.upTime   < now,
      t_down = 0;

  if (keyDown && keyUp) {
     if (key_values.downTime < key_values.upTime) {
       // Case 1
       // |  D      U |
       t_down = key_values.upTime - key_values.downTime;
     } else {
       // Case 2
       // | U      D |
       t_down = (now - key_values.downTime) + (key_values.upTime - last);
     }
  }
  // Case 3
  // |    U       |
  if (!keyDown && keyUp) {
    t_down = key_values.upTime - last;
  }

  // Case 4
  // |     D      |
  if (keyDown && !keyUp) {
    t_down = now - key_values.downTime;
  }

  // Case 5 & 6
  if (!keyDown && !keyUp) {
    if (key_values.state === KeyState.up) {
      t_down = 0;
    }
    if (key_values.state === KeyState.down) {
      t_down = now - last;
    }
  }

  return t_down;
}

/*
 * Returns the amount of time between @last@ and @now@ that an acceleration
 * occurred.
 *
 * Returns (t_down - t_up) where:
 * - t_up is the time the key was up between last and now.
 * - t_down is the time the key was down betwen last and now.
 *
 * This function can return a negative value! This means that t_up > t_down.
 * This means that it is a decelaration.
 *
 * Arguments:
 * - @values@ is the key values containing the upTime and the downTime.
 * - @last@ and @now@ are the boundaries of the time interval.
 */
function getAccelerateTime(last, now, values) {
    var t_down = getDownDuration(last,now,values);

    var accTime = (2*t_down - now + last);
    return accTime / 1000.0; // fraction of second
}

function constrain(value, minimum, maximum) {
  return Math.min(Math.max(value, minimum), maximum);
}

function accelerate_it(accTime, maximumVelocity, values) {
  var t    = Math.abs(accTime),
      sign = (accTime > 0) ? 1 : (-1),
      u    = values.velocity,
      a    = acceleration * sign;

  values.velocity = constrain(u + a*t, 0, maximumVelocity);
  
  return (u*t + 0.5*a*t*t);
}


function displacement_to_zoom_factor(z) {
  return z >= 0 ? z + 1 : 1/(1-z);
}

/*
 *
 * @direction@ is either -1, 0, or 1.
 * @value@ is of form { disp: <displacement>, velocity: <velocity> }
 *
 */
function accelerate(direction, accel, drag_coefficient, duration, value) {

  var t  = duration/1000.0;         

  var s0 = value.disp;

  var u  = value.velocity;
  var drag = drag_coefficient* Math.pow(Math.abs(u),0.5) *
             (u >= 0 ? 1 : -1); /* Drag is proportional to velocity */
  var a  = accel*direction - drag;
  var v  = u + a*t;
  var s  = s0 + u*t + 0.5*a*t*t;
  var new_value_state = { disp: s, velocity: v };
  return new_value_state;
}

function rotateAboutAxis(last, now, values, direction, axis, mvpMatrix) {
  /* t is in seconds not milliseconds */
  var accTime = getAccelerateTime(last, now, values), 
      axisVector, amount;

  switch (axis) {
    case Axis.x:
      axisVector = [ mvpMatrix[0], mvpMatrix[4], mvpMatrix[8] ];
      break;
    case Axis.y:
      axisVector = [ mvpMatrix[1], mvpMatrix[5], mvpMatrix[9] ];
      break;
    case Axis.z:
      axisVector = [ mvpMatrix[2], mvpMatrix[6], mvpMatrix[10] ];
      break;
  }

  amount = accelerate_it(accTime, maxVelocity, values);

  if (direction === RotationDirection.negative) {
    amount = amount * (-1.0);
  }

  mat4.rotate(mvpMatrix, amount, axisVector);
}

function setUniformsFromShadyUIs(canvas, gl, shaderProgram, time) {
  $('#' + canvas.id + ".shady-ui-widgets").find('.shady-ui').each(function(that) {
     var uniform_name = $(this).attr("glsl-name");
     var ui_type = $(this).attr("glsl-type");

     if ( uniform_name && ui_type ) {
       switch (ui_type) {
         case "time":
           gl.uniform1f(shaderProgram[uniform_name], time / slowDownFactor);
           break;
         case "float":
           gl.uniform1f(shaderProgram[uniform_name], parseFloat($(this).attr("glsl-value")));
           break;
         case "int":
           gl.uniform1f(shaderProgram[uniform_name], parseFloat($(this).attr("glsl-value")));
           break;

       }
     }
  });
}

/*
 * Creates the drawScene and keyHandler closures for each effect
 * See this Stack Overflow post for more detail on closures:
 *   http://stackoverflow.com/questions/111102/how-do-javascript-closures-work
 */
function createClosures(canvas, i) {
    var startTime = (new Date()).getTime();
    var gl, squareVertexPositionBuffer, shaderProgram,
        mvpMatrix = mat4.create(),
        normalMatrix = mat3.create(),
        lastTime = false,
        initValues = function() { return { upTime: startTime, downTime: 0,
                                           velocity: initVelocity, 
                                           state: KeyState.up } },
        key_values = { up:      initValues(),
                      down:    initValues(),
                      left:    initValues(),
                      right:   initValues() };


    mat4.identity(mvpMatrix);
    mat3.identity(normalMatrix);

    gl = initGL(canvas);

    if (!gl && i === 0) {
      alert("Could not initialise WebGL, sorry");
      return;
    } else if (!gl) {
      return;
    }
    shaderProgram = initShaders(gl, canvas.id);
    squareVertexPositionBuffer = initBuffers(gl);
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.enable(gl.DEPTH_TEST);

    var zoom_handlers = make_handlers([81 /*Q*/,90 /*Z*/], { disp: 0.0, velocity: 0.0},
      function(duration,key_states,value) {

        var direction = (key_states[90] === KeyState.down ? 1.0  : 0.0) +
                        (key_states[81] === KeyState.down ? -1.0 : 0.0);

        return accelerate(direction,5.0,1.0,duration,value);
      });

    var rotation_handlers   = 
      make_handlers([87/*W*/, 65/*A*/, 83/*S*/, 68/*D*/],
                   { phi_disp: 0.0, phi_velocity: 0.0,
                     theta_disp: 0.0, theta_velocity: 0.0 }, 
                     function(duration,key_states,value) {
        var a = 5.0, drag_coeff = 1.0;

        var theta_dir = (key_states[68] === KeyState.down ? 1.0  : 0.0) + 
                        (key_states[65] === KeyState.down ? -1.0 : 0.0),
            phi_dir   = (key_states[87] === KeyState.down ? 1.0  : 0.0) + 
                        (key_states[83] === KeyState.down ? -1.0 : 0.0),
            theta_values = accelerate(theta_dir,a,drag_coeff,duration,
                                      {disp:     value.theta_disp,
                                       velocity: value.theta_velocity }),
            phi_values = accelerate(phi_dir,a,drag_coeff,duration,
                                    {disp:     value.phi_disp,
                                     velocity: value.phi_velocity });

        return({ theta_disp: theta_values.disp, theta_velocity: theta_values.velocity,
                 phi_disp:   phi_values.disp,   phi_velocity: phi_values.velocity });
    });

    /* dsc = display scene closure */
    var dsc = function () {
      var time = (new Date()).getTime() - startTime;


      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute,
                             squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.uniformMatrix4fv(shaderProgram.mvpMatrixUniform, false, mvpMatrix);
      gl.uniformMatrix3fv(shaderProgram.normalMatrixUniform, false, normalMatrix);

      rotateView(lastTime || time, time, key_values, mvpMatrix);

      var z = zoom_handlers.frame_handler(lastTime || time, time).disp;
      gl.uniform1f(shaderProgram.zoomUniform,displacement_to_zoom_factor(z));

      var theta = rotation_handlers.frame_handler(lastTime || time, time).theta_disp;
      gl.uniform1f(shaderProgram.thetaUniform, theta);

      var phi = rotation_handlers.frame_handler(lastTime || time, time).phi_disp;
      gl.uniform1f(shaderProgram.phiUniform, phi);


      setUniformsFromShadyUIs(canvas, gl, shaderProgram, time);

      /* Now draw the frame */
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
      lastTime = time;
    }


    /* FIXME: Use newer key handler methodology */
    var camera_rotation_key_down_handler = function(e) {
      console.log("keycode = " + e.keyCode);
        keyHandle(startTime, e, key_values.up,      89, KeyState.down); // Y = 89;
        keyHandle(startTime, e, key_values.left,    71, KeyState.down); // G = 71;
        keyHandle(startTime, e, key_values.down,    72, KeyState.down); // H = 72;
        keyHandle(startTime, e, key_values.right,   74, KeyState.down); // J = 74;
    };

    /* FIXME: Use newer key handler methodology */
    var camera_rotation_key_up_handler = function(e) {
        keyHandle(startTime, e, key_values.up,      89, KeyState.up); // W = 87;
        keyHandle(startTime, e, key_values.left,    71, KeyState.up); // A = 65;
        keyHandle(startTime, e, key_values.down,    72, KeyState.up); // S = 83;
        keyHandle(startTime, e, key_values.right,   74, KeyState.up); // D = 68;
    };

    /* Set the handlers for this canvas */
    $(canvas).keyup(camera_rotation_key_down_handler);
    $(canvas).keydown(camera_rotation_key_up_handler);    

    [zoom_handlers, rotation_handlers].map(function(hs) {
      $(canvas).keyup(hs.key_up_handler);
      $(canvas).keydown(hs.key_down_handler);
    });

    setInterval(dsc, interval);
}

/* Modifies values parameter */
function keyHandle(startTime, e, values, keyCode, keyDirection) {
  var opposite, key;

  if (keyDirection === KeyState.up) {
    opposite = KeyState.down;
    key = "upTime";
  } else {
    opposite = KeyState.up;
    key = "downTime";
  }

  if (e.keyCode === keyCode && values.state === opposite) {
     values[key] = (new Date()).getTime() - startTime;
     values.state = keyDirection;
  }
}

/*
 *  @make_handlers@ returns three handlers that all manipulate a shared
 *  state. 
 *
 *  1. A key-down handler.
 *  2. A key-up handler.
 *  3. A frame handler. (Frame as in a frame of an animation.)
 *
 * The function @f@ (@f(duration, key_states, value)@) 
 * is a value updating function. It takes a
 * frame duration, the key states of various keys in
 * that frame, and object (of arbitrary form).
 * 
 * It should produce an object of that same form.
 *  
 * 
 * The handlers returned should be used as follows:
 *
 * 1. The key-down and key-up handlers should be added to (not overwrite)
 *    the key-down and key-up handlers for the canvas.
 * 2. The frame handler, which takes a @last@ and @now@ time
 *    (the endpoints of the frame) should be used to get the latest
 *    value. (The internal state of the value is updated in the process.)
 *    
 */
function make_handlers(key_codes, init_value, f) {

  /* Records time stamps when key was last up or down */
  var key_states = {}, value     = init_value;

  /* Initialise key_states */
  key_codes.map(function(key_code) { key_states[key_code]  = KeyState.up });

  /* 
   * These closures refer to @key_values@ and @current_value@.
   * The key handlers only do something if they key pressed has a 
   * @keyCode@ equal to @key_code@ parameter above.
   */
  var down_handler  = function(e) {
    key_codes.map(function(key_code) {
      if (e.keyCode == key_code ) { key_states[key_code] = KeyState.down}
    });
  };
  var up_handler    = function(e) { 
    key_codes.map(function(key_code) {
      if (e.keyCode == key_code ) { key_states[key_code] = KeyState.up}
    });
  };

  var frame_handler = function(last,now) {
    var duration = (now - last > 0 ? now - last : 0);
    return (value = f(duration, key_states, value));
  };

  return { key_up_handler:   up_handler,
           key_down_handler: down_handler,
           frame_handler:    frame_handler };
}

function webGLStart() {
    $(".playspace-canvas").each(function(i) {
      createClosures(this, i);
    });
}